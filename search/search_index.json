{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Experimental</p> <p>Plugins provided by ColorAide Extras is essentially an experimental playground. Regardless of how polished a given plugin may seem, they should be considered experimental.</p>"},{"location":"#overview","title":"Overview","text":"<p>ColorAide Extras is an add-on pack containing various plugins for ColorAide. The idea behind ColorAide Extras is to provide an environment for experimental color spaces, \u2206E methods, and other plugins.</p>"},{"location":"#installation","title":"Installation","text":"<p>The recommended way to install ColorAide Extras is to use <code>pip</code>:</p> <pre><code>$ pip install coloraide_extras\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Normally, it is advisable to only cherry pick color spaces you need. Rarely do people need every color space. This can be done simply by registering the color spaces you'd like.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide_extras.spaces.uvw import UVW\n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register(UVW())\n&gt;&gt;&gt; Color('red').convert('uvw')\ncolor(--uvw 171.8 24.715 52.261 / 1)\n</code></pre> Gamut: srgb <p>But, if you want access to all the color spaces for both ColorAide and ColorAide Extras, simply import <code>ColorAll</code> from <code>coloraide_extras.everything</code> instead of <code>coloraide</code>:</p> <pre><code>&gt;&gt;&gt; from coloraide_extras.everything import ColorAll as Color\n&gt;&gt;&gt; Color('color(--uvw 171.8 24.715 52.261 / 1)')\ncolor(--uvw 171.8 24.715 52.261 / 1)\n</code></pre> Gamut: srgb"},{"location":"playground/","title":"Playground","text":"Notebook Submit Cancel"},{"location":"about/changelog/","title":"Changelog","text":""},{"location":"about/changelog/#1121","title":"1.12.1","text":"<ul> <li>FIX: Adjust the spectral mixing to use a smaller epsilon that matches the current Spectral.js implementation.</li> </ul>"},{"location":"about/changelog/#112","title":"1.12","text":"<ul> <li>NEW: UVW color space now inherits from Luminant and Prism space.</li> <li>NEW: Require ColorAide 5.1.</li> </ul>"},{"location":"about/changelog/#111","title":"1.11","text":"<ul> <li>NEW: Support Python 3.14.</li> </ul>"},{"location":"about/changelog/#1101","title":"1.10.1","text":"<ul> <li>ENHANCE: Switch to deploying with PyPI's \"Trusted Publisher\".</li> <li>ENHANCE: Update internal algorithm of Spectral mixing to a more efficient approach.</li> </ul>"},{"location":"about/changelog/#110","title":"1.10","text":"<ul> <li>NEW: Sync types with latest ColorAide and require the latest ColorAide.</li> </ul>"},{"location":"about/changelog/#193","title":"1.9.3","text":"<ul> <li>FIX: Spectral interpolation should mix residual with the non-luminance-adjusted progress for better out of gamut     color mixing.</li> </ul>"},{"location":"about/changelog/#192","title":"1.9.2","text":"<ul> <li>FIX: Fix issues with spectral interpolation.</li> </ul>"},{"location":"about/changelog/#191","title":"1.9.1","text":"<ul> <li>FIX: Fix issue with how spectral interpolation concentrations are clipped.</li> </ul>"},{"location":"about/changelog/#19","title":"1.9","text":"<ul> <li>NEW: Drop Python 3.8.</li> <li>NEW: Require ColorAide 4.3.</li> <li>NEW: Add spectral interpolation that leverages Kubelka-Munk theory for color mixing.</li> </ul>"},{"location":"about/changelog/#18","title":"1.8","text":"<ul> <li>NEW: Officially support Python 3.13.</li> <li>NEW: Require ColorAide 4.0.</li> </ul>"},{"location":"about/changelog/#17","title":"1.7","text":"<ul> <li>NEW: Officially support Python 3.12.</li> </ul>"},{"location":"about/changelog/#16","title":"1.6","text":"<ul> <li>NEW: Drop Python 3.7.</li> <li>NEW: CIE 1960 UCS moved to official ColorAide repository.</li> </ul>"},{"location":"about/changelog/#15","title":"1.5","text":"<ul> <li>NEW: All CAM16 related spaces, and distancing plugins moved to official ColorAide.</li> <li>NEW: All HCT related spaces, gamut mapping, distancing, and contrast plugins moved to official ColorAide.</li> </ul>"},{"location":"about/changelog/#142","title":"1.4.2","text":"<ul> <li>FIX: Rework some internals to make tuning achromatic response easier.</li> <li>FIX: Simplify \u2206E<sub>HCT</sub> to just simple Euclidean logic against the components.</li> <li>FIX: Fix slowness of converting between CAM16 UCS Jab and JMh. JMh will convert from the Jab form instead of XYZ     directly to make translation between the Jab form and the JMh form much quicker.</li> <li>FIX: Calculation of achromatic response in CAM16 UCS JMh should take into account whether discounting is     enabled.</li> </ul>"},{"location":"about/changelog/#141","title":"1.4.1","text":"<ul> <li>FIX: Fix ranges on CAM16 UCS JMh.</li> </ul>"},{"location":"about/changelog/#14","title":"1.4","text":"<ul> <li>NEW: Add CAM16 UCS JMh</li> <li>NEW: Allow HCT to work with HDR color spaces.</li> <li>NEW: Add \u2206E<sub>HCT</sub> for use in <code>hct-chroma</code> gamut mapping.</li> <li>FIX: Improve results of <code>hct-chroma</code> gamut mapping for better tonal pallets.</li> </ul>"},{"location":"about/changelog/#13","title":"1.3","text":"<ul> <li>NEW: Add <code>hct-chroma</code> gamut mapping algorithm that reduces chroma in HCT until the color is in gamut.</li> <li>FIX: When converting from HCT and tone is 0 or 100, shortcut and return white or black.</li> </ul>"},{"location":"about/changelog/#12","title":"1.2","text":"<ul> <li>NEW: Add HCT color space.</li> <li>NEW: Add Lstar contrast (contrast based on lightness difference in the Lab color space).</li> </ul>"},{"location":"about/changelog/#11","title":"1.1","text":"<ul> <li>NEW: Require stable ColorAide 1.5.</li> <li>NEW: Formally support Python 3.11.</li> </ul>"},{"location":"about/changelog/#101","title":"1.0.1","text":"<ul> <li>FIX: <code>coloraide_extras.everything.ColorAll</code> should derive from <code>coloraide.everything.ColorAll</code>, not     <code>coloraide.Color</code>.</li> <li>FIX: Handle divide by zero case for Weber contrast by setting a more reasonable max.</li> </ul>"},{"location":"about/changelog/#10post1","title":"1.0.post1","text":"<ul> <li>FIX: Remove beta notices from documentation.</li> </ul>"},{"location":"about/changelog/#10","title":"1.0","text":"<ul> <li>NEW: Update to support the official ColorAide stable release. Move to a \"stable\" release for ColorAide Extras.</li> </ul>"},{"location":"about/changelog/#10rc1","title":"1.0rc1","text":"<ul> <li>NEW: Move the <code>Color</code> object which contains all plugins to <code>coloraide_extras.everything.ColorAll</code>. This will     prevent instantiating things that some users may not care about.</li> <li>NEW: Plugins are no longer available root of package, but must be imported from their location:     <code>coloraide_extras.&lt;plugin_type&gt;.&lt;space&gt;.&lt;class&gt;</code>.</li> <li>FIX: Clamp luminance in Michelson and Weber contrast plugins to zero if negative luminance.</li> <li>FIX: Adjust some color space ranges to be more reasonable.</li> </ul>"},{"location":"about/changelog/#10b1","title":"1.0b1","text":"<ul> <li>NEW: Add support for new ColorAide 1.0 Beta.</li> <li>NEW: All previous color spaces except UCS and UVW have been moved to ColorAide 1.0 Beta.</li> <li>NEW: Added CAM16 UCS, CAM16 LCD, and CAM16 SCD and an associated <code>cam16</code> \u2206E.</li> <li>NEW: Added Weber contrast and Michelson contrast.</li> </ul>"},{"location":"about/changelog/#051","title":"0.5.1","text":"<ul> <li>FIX: Fix Hunter Lab values.</li> </ul>"},{"location":"about/changelog/#050","title":"0.5.0","text":"<ul> <li>NEW: Update to support ColorAide 0.16.0 changes.</li> </ul>"},{"location":"about/changelog/#040","title":"0.4.0","text":"<ul> <li>NEW: Added oRGB color space.</li> </ul>"},{"location":"about/changelog/#030","title":"0.3.0","text":"<ul> <li>NEW: Updated to work with ColorAide 0.15.0 (now the required minimum) as there were substantial changes.</li> <li>NEW: Added support for RLAB color space.</li> </ul>"},{"location":"about/changelog/#020","title":"0.2.0","text":"<ul> <li>NEW: Updated to work with latest ColorAide.</li> <li>FIX: IPT and IgPgTg mismatched channel association (<code>p</code> &lt;=&gt; <code>t</code>). This also broke round trip conversions.</li> </ul>"},{"location":"about/changelog/#012","title":"0.1.2","text":"<ul> <li>FIX: Fix UVW calculation when <code>u = v = w = 0</code>.</li> </ul>"},{"location":"about/changelog/#011","title":"0.1.1","text":"<ul> <li>FIX: Fix some divide by zero cases in some of the color spaces.</li> <li>FIX: Fix CMYK logic.</li> </ul>"},{"location":"about/changelog/#010","title":"0.1.0","text":"<ul> <li>NEW: Initial release.</li> </ul>"},{"location":"about/contributing/","title":"Contributing &amp; Support","text":"<p>There are many ways to help support this project, regardless of skills and abilities. If you enjoy this project and want to get involved, consider checking out one of the various ways below. Feel free to get creative, there may be other ways to contribute in which we have not thought of!</p>"},{"location":"about/contributing/#become-a-sponsor","title":"Become a Sponsor","text":"<p>Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal.</p> <p> GitHub Sponsors  PayPal</p>"},{"location":"about/contributing/#bug-reports","title":"Bug Reports","text":"<ol> <li> <p>Please read the documentation and search the issue tracker to try and find the answer to your question     before posting an issue.</p> </li> <li> <p>When creating an issue on the repository, please provide as much info as possible:</p> <ul> <li>Version being used.</li> <li>Operating system.</li> <li>Version of Python.</li> <li>Errors in console.</li> <li>Detailed description of the problem.</li> <li>Examples for reproducing the error.  You can post pictures, but if specific text or code is required to     reproduce the issue, please provide the text in a plain text format for easy copy/paste.</li> </ul> <p>The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue.</p> </li> <li> <p>Be prepared to answer questions and provide additional information if required.  Issues in which the creator refuses     to respond to follow up questions will be marked as stale and closed.</p> </li> </ol>"},{"location":"about/contributing/#reviewing-code","title":"Reviewing Code","text":"<p>Take part in reviewing pull requests and/or reviewing direct commits.  Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.</p>"},{"location":"about/contributing/#answer-questions-in-issues","title":"Answer Questions in Issues","text":"<p>Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for.  Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.</p>"},{"location":"about/contributing/#pull-requests","title":"Pull Requests","text":"<p>Pull requests are welcome, and a great way to help fix bugs and add new features.</p>"},{"location":"about/contributing/#documentation-improvements","title":"Documentation Improvements","text":"<p>A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation.  If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.</p>"},{"location":"about/license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2022 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"colors/","title":"Supported Color Spaces","text":"<p>ColorAide Extras adds a number of additional color spaces to ColorAide. Some are just spaces that are less practical to use for common cases, some are just interesting for specific applications, some are implemented just for history, and some are fairly new and a bit experimental.</p> <p>Click a color space to learn more.</p> <pre><code>%%{init: {\"flowchart\": {\"useMaxWidth\": true}}}%%\nflowchart TB\n\n    uvw --- xyz-d65\n\n    xyz-d65(XYZ D65)\n    uvw(CIE 1964 UVW)\n\n    click xyz-d65 \"https://facelessuser.github.io/coloraide/colors/xyz_d65/\" _blank\n    click uvw \"./uvw\" _self</code></pre>"},{"location":"colors/uvw/","title":"CIE 1964 UVW","text":"<p>Properties</p> <p>Name: <code>uvw</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>u</code> [-100.0, 100.0] <code>v</code> [-100.0, 100.0] <code>w</code> [0.0, 100.0] <p><sup>*</sup> Range is currently quite arbitrary.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the UVW color space.</p> <p>Note</p> <p>It is a bit uncertain as to why the 3D model shows a number of values resolving to a black bulb under the shape, but the translation has been compared against some other libraries that have implemented the space, and it seems to align .</p> <p>Wyszecki invented the UVW color space in order to be able to calculate color differences without having to hold the luminance constant. He defined a lightness index W* by simplifying expressions suggested earlier by Ladd and Pinney, and Glasser et al.. The chromaticity components U* and V* are defined such that the white point maps to the origin, as in Adams chromatic valence color spaces.</p> <p>Learn more.</p>"},{"location":"colors/uvw/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>u</code> <code>v</code> <code>w</code>"},{"location":"colors/uvw/#inputoutput","title":"Input/Output","text":"<p>The UVW space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--uvw</code>:</p> <pre><code>color(--uvw u v w / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--uvw u v w / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"uvw\", [171.8, 24.715, 52.261])\ncolor(--uvw 171.8 24.715 52.261 / 1)\n&gt;&gt;&gt; Color(\"uvw\", [73.871, 48.705, 73.965]).to_string()\n'color(--uvw 73.871 48.705 73.965)'\n</code></pre> Gamut: srgb"},{"location":"colors/uvw/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide_extras.spaces.uvw import UVW\n\nclass Color(Base): ...\n\nColor.register(UVW())\n</code></pre>"},{"location":"contrast/","title":"Contrast","text":"<p>ColorAide provides WCAG 2.1 color contrast by default, but there are some criticisms related to how well the WCAG 2.1 algorithm performs. This is not a failing of ColorAide, but the contrast algorithm in general.</p> <p>ColorAide Extras currently provides a few color contrast methods for evaluating other approaches.</p> Methods Symmetrical Description <code>weber</code> Contrast that uses the measure also referred to as Weber fraction. <code>michelson</code> Peak-to-peak contrast."},{"location":"contrast/michelson/","title":"Michelson Contrast","text":""},{"location":"contrast/michelson/#description","title":"Description","text":"<p>Michelson contrast (also known as the visibility) is commonly used for patterns where both bright and dark features are equivalent and take up similar fractions of the area (e.g. sine-wave gratings). It measures the relation between the spread and the sum of the two luminances. This method does not care which color is text or background.</p> <pre>\\[\n\\frac{L_{max} - L_{min}}{L_{max} + L_{min}}\n\\]</pre> <pre><code>&gt;&gt;&gt; Color('red').contrast('blue', method='michelson')\n0.49308724161083384\n</code></pre> Gamut: srgb"},{"location":"contrast/michelson/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide_extras.contrast.contrast_weber import ContrastMichelson\n\nclass Color(Base): ...\n\nColor.register(ContrastMichelson())\n</code></pre>"},{"location":"contrast/weber/","title":"Weber Contrast","text":""},{"location":"contrast/weber/#description","title":"Description","text":"<p>Weber contrast is commonly used in cases where small features are present on a large uniform background, i.e., where the average luminance is approximately equal to the background luminance. The algorithm takes the difference of the luminance and divides it by the lesser value. This method does not care which color is text or background.</p> <pre>\\[\n\\frac{L_{max} - L_{min}}{L_{min}}\n\\]</pre> <pre><code>&gt;&gt;&gt; Color('red').contrast('blue', method='weber')\n1.9454520859870799\n</code></pre> Gamut: srgb"},{"location":"contrast/weber/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide_extras.contrast.contrast_weber import ContrastWeber\n\nclass Color(Base): ...\n\nColor.register(ContrastWeber())\n</code></pre>"},{"location":"interpolate/","title":"Interpolate","text":"<p>ColorAide Extras provides a few experimental interpolation plugins</p> Methods Description <code>spectral</code> An interpolation plugin that allows for single constant Kubelka-Munk interpolation reflectance curves generated from the sRGB gamut. <code>spectral-continuous</code> A continuous interpolation version of the <code>spectral</code> interpolator."},{"location":"interpolate/spectral/","title":"Spectral Interpolation","text":""},{"location":"interpolate/spectral/#description","title":"Description","text":"<p>Light, on its own, doesn't mix like pigments due to the way pigments absorb and scatter light. Kubelka-Munk theory is a fundamental approach to modelling the appearance of paint films and predicting this absorption and scattering. Utilizing Kubelka-Munk theory, colors can be simulated to mix more like paints.</p> <pre><code>&gt;&gt;&gt; red = Color('rgb(128, 2, 46)').mix('white', 0.25, method='spectral')\n&gt;&gt;&gt; yellow = Color('rgb(252, 211, 0)').mix('white', 0.25, method='spectral')\n&gt;&gt;&gt; blue = Color('rgb(13, 27, 68)').mix('white', 0.25, method='spectral')\n&gt;&gt;&gt; Wheel(Color.steps([red, yellow, blue, red], steps=13, method='spectral', out_space='srgb')[:-1])\n[color(srgb 0.68582 0.08547 0.31995 / 1), color(srgb 0.75585 0.16984 0.25944 / 1), color(srgb 0.89806 0.36096 0.22515 / 1), color(srgb 0.98212 0.636 0.18225 / 1), color(srgb 0.98896 0.84036 0.07636 / 1), color(srgb 0.78045 0.80098 0.15516 / 1), color(srgb 0.48919 0.65041 0.24401 / 1), color(srgb 0.24505 0.4497 0.34033 / 1), color(srgb 0.20956 0.3397 0.59235 / 1), color(srgb 0.26307 0.26283 0.53214 / 1), color(srgb 0.34787 0.16819 0.4047 / 1), color(srgb 0.52824 0.12714 0.33725 / 1)]\n&gt;&gt;&gt; Steps(Color.steps([red, yellow, blue, red], steps=13, method='spectral', out_space='srgb')[:-1])\n[color(srgb 0.68582 0.08547 0.31995 / 1), color(srgb 0.75585 0.16984 0.25944 / 1), color(srgb 0.89806 0.36096 0.22515 / 1), color(srgb 0.98212 0.636 0.18225 / 1), color(srgb 0.98896 0.84036 0.07636 / 1), color(srgb 0.78045 0.80098 0.15516 / 1), color(srgb 0.48919 0.65041 0.24401 / 1), color(srgb 0.24505 0.4497 0.34033 / 1), color(srgb 0.20956 0.3397 0.59235 / 1), color(srgb 0.26307 0.26283 0.53214 / 1), color(srgb 0.34787 0.16819 0.4047 / 1), color(srgb 0.52824 0.12714 0.33725 / 1)]\n</code></pre> Gamut: srgb <p>The \"spectral\" interpolation method is based on Kubelka-Munk theory and, more specifically, follows after the approach implemented in the Spectral.js project. Spectral.js approximates paint mixing by using spectral data to generate reflectance curves and uses them to mix colors by applying Kubelka-Munk theory. This approach is also based off the work that was done during the development of another project, Mixbox. More specifically, it is based on the paper that the Mixbox folks published.</p> <p>While Mixbox uses real paint data and tries to model these paints as close as it can, the \"spectral\" approach tries more to capture the feel of mixing paints without specifically basing it off real paint data.</p> Spectral MixRGB Mix <pre><code>&gt;&gt;&gt; c1 = Color('#002185')\n&gt;&gt;&gt; c2 = Color('#FCD200')\n&gt;&gt;&gt; Color.interpolate([c1, c2], method='spectral')\n&lt;coloraide_extras.interpolate.spectral.InterpolatorSpectralLinear object at 0x111972c30&gt;\n&gt;&gt;&gt; Steps(Color.steps([c1, c2], method='spectral', steps=9))\n[color(xyz-d65 0.04777 0.02781 0.22476 / 1), color(xyz-d65 0.02667 0.03298 0.0951 / 1), color(xyz-d65 0.03708 0.06387 0.07248 / 1), color(xyz-d65 0.07117 0.12699 0.07519 / 1), color(xyz-d65 0.13265 0.22305 0.08176 / 1), color(xyz-d65 0.22548 0.34363 0.08795 / 1), color(xyz-d65 0.34991 0.47284 0.09246 / 1), color(xyz-d65 0.49784 0.59012 0.09493 / 1), color(xyz-d65 0.6319 0.6679 0.09564 / 1)]\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; c1 = Color('#002185')\n&gt;&gt;&gt; c2 = Color('#FCD200')\n&gt;&gt;&gt; Color.interpolate([c1, c2], space='srgb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x11188dd30&gt;\n&gt;&gt;&gt; Steps(Color.steps([c1, c2], space='srgb', steps=9))\n[color(srgb 0 0.12941 0.52157 / 1), color(srgb 0.12353 0.21618 0.45637 / 1), color(srgb 0.24706 0.30294 0.39118 / 1), color(srgb 0.37059 0.38971 0.32598 / 1), color(srgb 0.49412 0.47647 0.26078 / 1), color(srgb 0.61765 0.56324 0.19559 / 1), color(srgb 0.74118 0.65 0.13039 / 1), color(srgb 0.86471 0.73676 0.0652 / 1), color(srgb 0.98824 0.82353 0 / 1)]\n</code></pre> Gamut: srgb"},{"location":"interpolate/spectral/#how-it-works","title":"How It Works","text":"<p>The idea is simple enough. Create a palette of primary colors from which you can mix and get all the colors within your desired gamut, which in our case is sRGB. Once the colors are selected, reflectance curves need to be generated for those primary colors. There are various ways in which such curves could be created, but the chosen approach that was settled on involves applying applying the research of Scott Burns. His research details a way to use spectral data to approximate reflectance curves for any color within the sRGB gamut.</p> <p></p> <p>Figure 1. Reflectance curves of cyan, magenta, yellow, red, green, and blue as approximated using the method proposed by Scott Burns.</p> <p>With our primary colors selected and the reflectance curves created for each one, we can use these curves to create any color within our gamut. More interestingly, we can take a color and deconstruct it into concentrations of these primary reflectance curves and then construct a new curve that represents the color.</p> <p></p> <p>Figure 2. Orange decomposed into cyan, magenta, yellow, red, green, and blue reflectance curves and then reconstructed into its own curve.</p> <p>With the ability to represent almost any color within our gamut as a reflectance curve, we then can mix colors by identifying what the curves are and then applying Kubelka-Munk theory, converting those curves into absorption and scattering data and mixing them. Once mixed, we can transform them back to a reflectance curve and then back to our target color space.</p> <p></p> <p>Figure 3. Mixing a blue and yellow color with Kubelka-Munk theory.</p> <p>Kubelka-Munk theory can be used in a couple of ways, one that utilizes absorption and scattering data independent of each other, which can be referred to as the two-constant approach, and one that treats the absorption and scattering as a single constant, which we will call the single-constant approach. Generally, for paint, the two-constant approach is probably more accurate, but since we generate the reflectance curves without knowing specifically what the absorption vs scattering properties are, especially since this is not based off real paint data, the \"spectral\" mixing uses the single-constant approach.</p> <p>Lastly, because the single-constant approach we are using produces colors a bit more darkly, Spectral.js applies an easing function to the interpolation progress that favors the more dominant luminance when mixing, biasing the color more towards the color with more intense luminance. This is applied to give a more aesthetically pleasing mix that appears more like what you wound have when using something like Mixbox.</p>"},{"location":"interpolate/spectral/#differences","title":"Differences","text":"<p>It should be noted that we do deviate a bit from the Spectral.js implementation. As we explored this approach we found a few things that we found to be unnecessary, things we could improve upon, or just things we approached slightly different.</p> <ol> <li> <p>Following the approach outlined by Scott Burns, we regenerated all the data at higher precision and ensured that it     was done with the same transformation matrices and white points that we use within our library. This was done just     to ensure we have more precise transforms within our library. Generally, the approach is the same as what     Spectral.js does, but values might be slightly different as we did the calculations ourselves with our exact     white points and matrices.</p> </li> <li> <p>Spectral.js uses primary colors of:</p> <ul> <li><code>rgb(255 255 255)</code></li> <li><code>rgb(255 0 0)</code></li> <li><code>rgb(0 255 0)</code></li> <li><code>rgb(0 0 255)</code></li> <li><code>rgb(0 255 255)</code></li> <li><code>rgb(255 0 255)</code></li> <li><code>rgb(255 255 0)</code></li> </ul> <p>During our evaluation, we found that including <code>rgb(255 255 255)</code> provided no significant improvements as the other primary colors provide sufficient coverage with comparable results.</p> <p>Note</p> <p>It should be noted that it was recently discovered that Spectral.js requires white data because their concentration calculation is slightly different than ours and has an issue. If they adopt a similar way of decomposing RGB into cyan, magenta, yellow, red, green, and blue, they should be able to drop white as well, if they choose to do so.</p> </li> <li> <p>During decomposition of colors, we constrain concentrations to be between 0 and 1. Concentrations are always     relative to the colors they are mixing with, so you can't have 200% of red of 100% as what this really represents     is 2 parts red and 1 part blue, which equates to 0.6666666666666666% and 0.3333333333333333% of blue. You can never     mix more than 100% of a given wavelength as it would create unrealistic reflectance curves that would break when     performing the Kubelka-Munk mix. Spectral.js only constrains the lower end.</p> <p>Additionally, we constrain composite reflectance curves to be between a very small value and 1 as the Kubelka-Munk functions expect reflectance to not be zero and not exceed 1. The Kubelka-Munk mixing function does not handle values that exceed 1 very well and cannot round trip these values. Spectral.js only constrains the lower end.</p> <p>These changes will alter the curve compared to Spectral.js when getting very close to white or exceeding the sRGB gamut. The primary curves do not sum up to 1 perfectly and can sum to values greater than 1. This means color information is lost, but the information would be inaccurate when passing through the Kubelka-Munk mixing functions.</p> <p>We compensate for the color information that is lost by capturing the residual (the difference between the expected XYZ value and the recreated XYZ value) and mixing those separately and then adding the mixed residual back into the final color at the end. This allows us to reasonably represent colors that may exceed the actual gamut that the primary reflectance curves can actually reproduce and even colors that exceed the sRGB gamut entirely. It should be noted though that colors within the sRGB gamut should be considered to have more accurate Kubelka-Munk mixing as there will only be slight clamping within sRGB colors when they get close to white.</p> <p>Better stated, the Spectral.js approach can process most of the colors in the sRGB gamut well, but not all. Our adjusted approach allows us to better handle colors at the edge of what the Spectral.js approach can support for the sRGB gamut and beyond.</p> <p>It should be noted though that Spectral.js does clamp their final result to the course resolution of sRGB hexadecimal values, and because they are limited to the sRGB gamut only, and to such a low resolution, inaccuracies are not easily observable. Since we allow for higher precision and larger gamuts, we cannot get away with the same approach and require some mitigation.</p> </li> <li> <p>Spectral.js generally clips the mixed colors to sRGB hexadecimal resolution before returning them. We do not clip     any colors that are out-of-gamut due to mixing in case the user is within a gamut that can accommodate them. We     also do not force hexadecimal resolution. We let the user choose how they will gamut map their colors and to what     resolution they wish to round their values to. This means we allow colors that exceed the sRGB gamut if that is     desired. In short, users are free to clip or gamut map their returned colors in any way they see fit.</p> <pre><code>&gt;&gt;&gt; c1 = Color('color(display-p3 0 0 1)')\n&gt;&gt;&gt; c2 = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; Color.interpolate([c1, c2], method='spectral')\n&lt;coloraide_extras.interpolate.spectral.InterpolatorSpectralLinear object at 0x111a3abe0&gt;\n&gt;&gt;&gt; Steps(Color.steps([c1, c2], method='spectral', steps=9))\n[color(xyz-d65 0.19822 0.07929 1.0439 / 1), color(xyz-d65 0.06051 0.0615 0.29103 / 1), color(xyz-d65 0.05131 0.07666 0.17683 / 1), color(xyz-d65 0.07157 0.12065 0.13913 / 1), color(xyz-d65 0.12297 0.20065 0.11708 / 1), color(xyz-d65 0.21721 0.32545 0.09921 / 1), color(xyz-d65 0.36095 0.49724 0.08216 / 1), color(xyz-d65 0.54818 0.70664 0.06461 / 1), color(xyz-d65 0.75224 0.92071 0.04511 / 1)]\n</code></pre> Gamut: srgb </li> <li> <p>Lastly, Spectral.js has the concept of \"tinting strength\". It is essentially parameter to manually adjust the     weight of a color when mixing. It is a fiddly way to subjectively adjust the interpolation between individual     colors. We do not implement this and all interpolations essentially perform as if the \"tinting strength\" is set to 1     which causes this variable to drop out.</p> </li> </ol>"},{"location":"interpolate/spectral/#registering","title":"Registering","text":"<p>Spectral mixing comes in two flavors, one which operations in normal piecewise linear, the other which uses the \"continuous\" approach when handling undefined channels.</p> <pre><code>from coloraide import Color as Base\nfrom coloraide_extras.interpolate.spectral import Spectral, SpectralContinuous\n\nclass Color(Base): ...\n\nColor.register(Spectral())\nColor.register(SpectralContinuous())\n</code></pre>"}]}